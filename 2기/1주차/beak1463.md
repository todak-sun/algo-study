# StarStamp


문제
====
정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.

1. X가 3으로 나누어 떨어지면, 3으로 나눈다.
2. X가 2로 나누어 떨어지면, 2로 나눈다.
3. 1을 뺀다.

정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.

입력
====
첫째 줄에 1보다 크거나 같고, 106보다 작거나 같은 정수 N이 주어진다.

출력
====
첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.

#### 예제 입력 1 

##### 2

#### 예제 출력 1

##### 1

#### 예제 입력 2

##### 10

#### 예제 출력 2

##### 3

힌트
----
10의 경우에 10 -> 9 -> 3 -> 1 로 3번 만에 만들 수 있다.



출처 : [백준](https://www.acmicpc.net/problem/1463 "백준")
------------------------------------------------------------

고찰의 시간
------------------
문제를 처음본 나는 가장 큰 3의 제곱으로 나누고 그 다음 큰 2의 제곱으로 나누고


나머지 상수값을 더하면 이동거리가 최소거리겠구나 싶었다.


이렇게 생각하고 풀고있는데 힌트를 보고 잘못된 풀이라는걸 알게됐다. 


처음 생각대로 풀게 된다면


10 -> 5 -> 4 -> 2 -> 1


무려 이동거리가 4번이 된다.


수학적으로 접근해서 풀어봤는데,


먼저 목표값을 도달하는 방정식을 만들었다.


x = 3^a + 2^b + c


위 방정식에서 a+b+c가 이동거리이므로 a+b+c의 최소값을 구하기만 하면 된다.


슬롯머신처럼 띠리리리링 돌아가면서 바뀌는 것을 연상하며


a b c 로 루프돌면서 최소값을 찾았다.


다풀고나서 문제를 인터넷어 검색해보니 다른 사람들은 재귀로 많이 했더라..


풀이
----
<pre>
<code>
public class Beak1463 {
	public static void main(String[] args) {

		int x = 10;	// 목표값
		int n[] = { log(x, 3), log(x, 2), x }; // 3의 제고 이동거리, 2의 제곱 이동거리, 나머지 변수의 이동거리
		
		int min = x; // 초기값은 목표값을 대입
		
		// 3중 반복문 a b c 계속 돔
		for (int i = 0; i <= n[0]; i++) {
			for (int j = 0; j <= n[1]; j++) {
				for (int k = 0; k <= n[2]; k++) {
					int pow1 = (int) pow(3, i); // log(3)i		ex) log(3)9 = 2
					int pow2 = (int) pow(2, j); // log(2)j
					if (pow1 + pow2 + k == x) {	// 지수와 나머지값 합들이 목표값과 같을 때 
						if (min > i + j + k) {	// 최솟값 대입
							min = i + j + k;
						}
					}
				}	// inner loop
			}
		}	// outer loop
		System.out.println("이동횟수 : " + min);

	}

	// 밑이 lnd이고 지수가 x인 로그값 구하기
	static int log(int x, int lnd) {
		return (int) (Math.log(x) / Math.log(lnd));
	}

	// 제곱근이 0일때 결과가 0이되야하는데 2^0=1 이되므로 pow 오버라이딩해서 제곱근이 0일때, 0 반환
	public static double pow(int a, int b) {
		if (b == 0) {
			return 0;
		}
		return StrictMath.pow(a, b); // default impl. delegates to StrictMath
	}
}
</code>
</pre>
